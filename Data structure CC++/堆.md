### 堆

#### 完全二叉树

若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都**连续集中在最左边**，这就是完全二叉树。

#### 最大堆

1. 是完全二叉树
2. 每个节点的元素值不小于其子节点的元素值（显然，头节点是所有元素的最大值）

#### 最小堆

1. 是完全二叉树
2. 每个节点的元素值不大于其子节点的元素值

#### 最大堆的创建

````````c
typedef struct HeapStruct *MaxHeap;
struct HeapStruct{
	ElementType *Elements;
	int Size;
	int Capacity;
};
````````

+ 堆结构

```c
MaxHeap Create(int MacSize)
{
	MaxHeap H = malloc(sizeof(struct HeapStruct));
	H->Elements = malloc((MaxSize+1)*sizeof(ElementType));
	H->Size = 0;
	H->Capacity = MaxSize;
	H->Elements[0] = MaxData;
	return H;
}
```

+ 插入

```c
void Insert(MaxHeap H, ElementType item)
{
	int i;
	if(IsFull(H))
	{
		printf("the Heap is full.");
		return;
	}
	i = ++H->Size;
	for(; H->Elements[i/2] < item; i/=2) //让位思路，只要不满足从大到小的顺序，就让选定的元素让位
		H->Elements[i] = H->Elements[i/2];
	H->Elements[i] = item;
```

​	注意此处递归调用的思路。Line : 11, 12

H->Element[0]是**哨兵**元素，它不小于堆中的最大元素，控制循环结束。

- 删除

```c++
ElementType DeleteMax(MaxHeap H)
{
    int Parent, Child;
    ElementType MaxItem, temp;
    if( IsEmpty(H) )
    {
        printf("heap is already empty.");
        return;
    }
    MaxItem = H->Elements[1];
    temp = H->Elements(H->Size--);
    for(Parent=1; Parent*2<=H->Size; Parent=Child)//判断当前的parent是否有左儿子，即是否越界，将child位置上移之后，下一个parent就是当前child的值，这里是非常值得注意的。
    {
        Child = Parent * 2;//指向左儿子
        if((Child != H->Size) && (H->Elements[Child] < H->Elements[Child+1]))
            child++;//Child指向左右子节点的较大者
        if(temp >= H->Elemnts[child]) break;//temp比左右儿子都大，那就不需要再进行调整了
        else//否则到下一层进行比较
            H->Elements[Parens] = H->Elements[Child];
    }
    H->Elements[Parent] = temp;
    return MaxItem;
}
```

$T(N)\ =\ O(logN)$

- 最大堆的建立

将已经存在的$N$个元素按最大堆的要求存放在一个一维数组中。

所以最小的复杂度是什么呢？

1. 将N个元素按输入顺序存入，先满足完全二叉树的结构特性。
2. 调整各节点的位置， 以满足最大堆的**有序特性**：利用Delete思想。





